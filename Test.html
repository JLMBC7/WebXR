<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clickable AR Experience</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js"
        }
      }
    </script>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
    <style>
        :root { --primary-color: #4285f4; }
        body { 
            margin: 0; 
            font-family: sans-serif;
            background-color: #000; 
            overflow: hidden;
        }
        model-viewer {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #launch-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: opacity 0.5s;
        }
        .launch-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .toast {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            color: black;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 200;
        }

        .fire-hotspot {
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
            pointer-events: none;
        }

        .fire-container {
            width: 400px;
            height: 600px;
            transform: translate(-50%, -80%); 
        }

        #fire-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <div id="launch-overlay">
        <button class="launch-btn">Start Experience</button>
        <p>Tap to place the dumpster</p>
    </div>

    <model-viewer 
        id="ar-element"
        src="https://raw.githubusercontent.com/JLMBC7/WebXR/0e9e07278b5c8e5a1211564afab135a1c72c0b78/DDOpenLid.glb" 
        ar 
        ar-modes="webxr scene-viewer quick-look" 
        ar-placement="floor"
        camera-controls 
        shadow-intensity="1" 
        auto-rotate
        loading="eager"
        alt="Open Dumpster AR Experience">
        
        <button class="fire-hotspot" slot="hotspot-fire" data-position="0m 0.5m 0m" data-normal="0m 1m 0m">
            <div class="fire-container">
                <canvas id="fire-canvas"></canvas>
            </div>
        </button>

        <button slot="ar-button" style="display: none;"></button>
    </model-viewer>

    <div id="toast" class="toast">Opening Link...</div>

    <script type="module">
        import * as THREE from 'three';

        // Volumetric Fire Material implementation
        const vertexShader = `
            varying vec3 vWorldPos;
            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            }
        `;

        const fragmentShader = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 =   v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            uniform vec3 color;
            uniform float time;
            uniform float seed;
            uniform mat4 invModelMatrix;
            uniform vec3 scale;
            uniform vec4 noiseScale;
            uniform float magnitude;
            uniform float lacunarity;
            uniform float gain;
            uniform sampler2D fireTex;
            varying vec3 vWorldPos;

            #define ITERATIONS 10
            #define OCTIVES 3

            float turbulence(vec3 p) {
                float sum = 0.0;
                float freq = 1.0;
                float amp = 1.0;
                for(int i = 0; i < OCTIVES; i++) {
                    sum += abs(snoise(p * freq)) * amp;
                    freq *= lacunarity;
                    amp *= gain;
                }
                return sum;
            }

            vec4 samplerFire (vec3 p, vec4 nScale) {
                vec2 st = vec2(sqrt(dot(p.xz, p.xz)), p.y);
                if(st.x <= 0.0 || st.x >= 1.0 || st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);
                p.y -= (seed + time) * nScale.w;
                p *= nScale.xyz;
                st.y += sqrt(st.y) * magnitude * turbulence(p);
                if(st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);
                // Multiply texture sample by color uniform
                return texture2D(fireTex, st) * vec4(color, 1.0);
            }

            vec3 localize(vec3 p) {
                return (invModelMatrix * vec4(p, 1.0)).xyz;
            }

            void main() {
                vec3 rayPos = vWorldPos;
                vec3 rayDir = normalize(rayPos - cameraPosition);
                float rayLen = 0.0288 * length(scale.xyz);
                vec4 col = vec4(0.0);
                for(int i = 0; i < ITERATIONS; i++) {
                    rayPos += rayDir * rayLen;
                    vec3 lp = localize(rayPos);
                    lp.y += 0.5;
                    lp.xz *= 2.0;
                    col += samplerFire(lp, noiseScale);
                }
                col.a = col.r;
                gl_FragColor = col;
            }
        `;

        const modelViewer = document.querySelector("#ar-element");
        const launchOverlay = document.getElementById('launch-overlay');
        const toast = document.getElementById('toast');
        const canvas = document.getElementById('fire-canvas');

        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setSize(400, 600);
        renderer.setPixelRatio(window.devicePixelRatio);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, 400 / 600, 0.1, 100);
        camera.position.set(0, 0, 10);
        camera.lookAt(0, 0, 0);

        // Updated with your raw GitHub texture URL
        const textureLoader = new THREE.TextureLoader();
        const fireTex = textureLoader.load('https://raw.githubusercontent.com/JLMBC7/WebXR/9b855209f35c695958951dfca2b09ab1f65c4597/fire.png'); 
        fireTex.magFilter = fireTex.minFilter = THREE.LinearFilter;
        fireTex.wrapS = fireTex.wrapT = THREE.ClampToEdgeWrapping;

        const fireMaterial = new THREE.ShaderMaterial({
            uniforms: {
                fireTex: { value: fireTex },
                color: { value: new THREE.Color(0xffffff) }, // Pure white to show texture colors
                time: { value: 0.0 },
                seed: { value: Math.random() * 19.19 },
                invModelMatrix: { value: new THREE.Matrix4() },
                scale: { value: new THREE.Vector3(7, 7, 7) },
                noiseScale: { value: new THREE.Vector4(1, 2, 1, 0.3) },
                magnitude: { value: 2.5 },
                lacunarity: { value: 3.0 },
                gain: { value: 0.6 }
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            depthWrite: false,
            depthTest: false
        });

        const fireBox = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), fireMaterial);
        fireBox.scale.set(7, 7, 7);
        scene.add(fireBox);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            fireBox.updateMatrixWorld();
            const invModelMatrix = new THREE.Matrix4().copy(fireBox.matrixWorld).invert();
            
            fireMaterial.uniforms.time.value = elapsedTime;
            fireMaterial.uniforms.invModelMatrix.value = invModelMatrix;
            fireMaterial.uniforms.scale.value = fireBox.scale;

            renderer.render(scene, camera);
        }
        animate();

        launchOverlay.addEventListener('click', () => {
            if (modelViewer.canActivateAR) modelViewer.activateAR();
            launchOverlay.style.opacity = '0';
            setTimeout(() => launchOverlay.style.display = 'none', 500);
        });

        modelViewer.addEventListener('click', (event) => {
            const hit = modelViewer.positionAndNormalFromPoint(event.clientX, event.clientY);
            if (hit) {
                toast.style.opacity = '1';
                setTimeout(() => window.location.href = "https://www.google.com", 800);
            }
        });
    </script>
</body>
</html>